{
    "docs": [
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nInstall the bundle\n\n\nAdd bundle to your project:\n\n\ncomposer require batchOperation-bundle\n\n\n\nAdd \nWelp\\BatchBundle\\WelpBatchBundle\n to your \nAppKernel.php\n:\n\n\n$bundles = [\n    // ...\n    new Welp\\BatchBundle\\WelpBatchBundle(),\n];\n\n\n\nExtends the models\n\n\nIn order to use this bundle, you have to extends our two models : \nWelp\\BatchBundle\\Model\\Batch\n and \nWelp\\BatchBundle\\Model\\Operation\n\n\nExample :\n\n\n/**\n * @ORM\\Entity()\n * @ORM\\Table(name=\nbatch\n)\n * @ORM\\HasLifecycleCallbacks\n */\nclass Batch extends BaseBatch\n{\n\n    /**\n     * @var int\n     *\n     * @ORM\\Id\n     * @ORM\\Column(type=\ninteger\n)\n     * @ORM\\GeneratedValue(strategy=\nAUTO\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name=\nstatus\n, type=\nstring\n, length=255)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $status;\n\n    /**\n     * @var string\n     *\n     * @ORM\\OneToMany(targetEntity=\nOperation\n, mappedBy=\nbatch\n, cascade={\npersist\n, \nremove\n})\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     *\n     */\n    protected $operations;\n\n    /**\n     * @var integer\n     *\n     * @ORM\\Column(name=\ntotal_operations\n, type=\ninteger\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $totalOperations;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name=\ntotal_executed_operations\n, type=\ninteger\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $totalExecutedOperations;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name=\nerrors\n, type=\narray\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $errors;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\ncreated_at\n, type=\ndatetime\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $createdAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nupdated_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $updatedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nstarted_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $startedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nfinished_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $finishedAt;\n}\n\n\n\n/**\n * @ORM\\Entity()\n * @ORM\\Table(name=\noperation\n)\n * @ORM\\HasLifecycleCallbacks\n */\nclass Operation extends BaseOperation\n{\n\n    /**\n     * @var int\n     *\n     * @ORM\\Id\n     * @ORM\\Column(type=\ninteger\n)\n     * @ORM\\GeneratedValue(strategy=\nAUTO\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name=\nstatus\n, type=\nstring\n, length=255)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $status;\n\n    /**\n     * @var array\n     *\n     * @ORM\\Column(name=\nerrors\n, type=\narray\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $errors;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name=\ntype\n, type=\nstring\n, length=255)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $type;\n\n    /**\n     * @var array\n     *\n     * @ORM\\Column(name=\npayload\n, type=\narray\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $payload;\n\n    /**\n     * @var Category\n     *\n     * @ORM\\ManyToOne(targetEntity=\nBatch\n, inversedBy=\noperations\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\MaxDepth(1)\n     * @Serializer\\Expose\n     */\n    protected $batch;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\ncreated_at\n, type=\ndatetime\n)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $createdAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nupdated_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $updatedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nstarted_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $startedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name=\nfinished_at\n, type=\ndatetime\n,nullable=true)\n     * @Serializer\\Groups({\nDefault\n})\n     * @Serializer\\Expose\n     */\n    protected $finishedAt;\n}\n\n\n\n\nConfiguration\n\n\ntake a look \nhere\n to configure the bundle", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#install-the-bundle", 
            "text": "Add bundle to your project:  composer require batchOperation-bundle  Add  Welp\\BatchBundle\\WelpBatchBundle  to your  AppKernel.php :  $bundles = [\n    // ...\n    new Welp\\BatchBundle\\WelpBatchBundle(),\n];", 
            "title": "Install the bundle"
        }, 
        {
            "location": "/installation/#extends-the-models", 
            "text": "In order to use this bundle, you have to extends our two models :  Welp\\BatchBundle\\Model\\Batch  and  Welp\\BatchBundle\\Model\\Operation  Example :  /**\n * @ORM\\Entity()\n * @ORM\\Table(name= batch )\n * @ORM\\HasLifecycleCallbacks\n */\nclass Batch extends BaseBatch\n{\n\n    /**\n     * @var int\n     *\n     * @ORM\\Id\n     * @ORM\\Column(type= integer )\n     * @ORM\\GeneratedValue(strategy= AUTO )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name= status , type= string , length=255)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $status;\n\n    /**\n     * @var string\n     *\n     * @ORM\\OneToMany(targetEntity= Operation , mappedBy= batch , cascade={ persist ,  remove })\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     *\n     */\n    protected $operations;\n\n    /**\n     * @var integer\n     *\n     * @ORM\\Column(name= total_operations , type= integer )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $totalOperations;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name= total_executed_operations , type= integer )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $totalExecutedOperations;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name= errors , type= array )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $errors;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= created_at , type= datetime )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $createdAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= updated_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $updatedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= started_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $startedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= finished_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $finishedAt;\n}  /**\n * @ORM\\Entity()\n * @ORM\\Table(name= operation )\n * @ORM\\HasLifecycleCallbacks\n */\nclass Operation extends BaseOperation\n{\n\n    /**\n     * @var int\n     *\n     * @ORM\\Id\n     * @ORM\\Column(type= integer )\n     * @ORM\\GeneratedValue(strategy= AUTO )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name= status , type= string , length=255)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $status;\n\n    /**\n     * @var array\n     *\n     * @ORM\\Column(name= errors , type= array )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $errors;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(name= type , type= string , length=255)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $type;\n\n    /**\n     * @var array\n     *\n     * @ORM\\Column(name= payload , type= array )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $payload;\n\n    /**\n     * @var Category\n     *\n     * @ORM\\ManyToOne(targetEntity= Batch , inversedBy= operations )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\MaxDepth(1)\n     * @Serializer\\Expose\n     */\n    protected $batch;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= created_at , type= datetime )\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $createdAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= updated_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $updatedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= started_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $startedAt;\n\n    /**\n     * @var \\DateTime\n     *\n     * @ORM\\Column(name= finished_at , type= datetime ,nullable=true)\n     * @Serializer\\Groups({ Default })\n     * @Serializer\\Expose\n     */\n    protected $finishedAt;\n}", 
            "title": "Extends the models"
        }, 
        {
            "location": "/installation/#configuration", 
            "text": "take a look  here  to configure the bundle", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nIn your \nconfig.yml\n:\n\n\nwelp_batch:\n    entity_manager: doctrine.orm.entity_manager #name of the entity manager service\n    broker_type: rabbitmq #type of the broker\n    broker_connection: default #name of the connection to the broker\n    batch_entity: #entity which extends the batc/operation Model\n        batch: AppBundle\\Entity\\Batch\n        operation: AppBundle\\Entity\\Operation\n    manage_entities: #Batchable entity\n        need:\n            entity_name: AppBundle\\Entity\\Need\n            form_name: ApiBundle\\Form\\NeedType\n            batch_size: 10\n            actions: ['create','delete']\n        proposition:\n            entity_name: AppBundle\\Entity\\Proposition\n            form_name: ApiBundle\\Form\\PropositionType\n            batch_size: 10\n            actions: ['create']\n\n\n\nmanage_entitites explanation\n\n\nYou can add as many entities as you like. Each of them must have the following attributes :\n\n\n\n\nentity_name : full name of the entity\n\n\nform_name : full name of the form corresponding to this entity. This form will be used to bind the given parameters to the new entity (see section TODO for more details)\n\n\nactions : array of action. At the moment, we only support create and delete\n\n\nbatch_size : number of message to take from the queue at a time.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "In your  config.yml :  welp_batch:\n    entity_manager: doctrine.orm.entity_manager #name of the entity manager service\n    broker_type: rabbitmq #type of the broker\n    broker_connection: default #name of the connection to the broker\n    batch_entity: #entity which extends the batc/operation Model\n        batch: AppBundle\\Entity\\Batch\n        operation: AppBundle\\Entity\\Operation\n    manage_entities: #Batchable entity\n        need:\n            entity_name: AppBundle\\Entity\\Need\n            form_name: ApiBundle\\Form\\NeedType\n            batch_size: 10\n            actions: ['create','delete']\n        proposition:\n            entity_name: AppBundle\\Entity\\Proposition\n            form_name: ApiBundle\\Form\\PropositionType\n            batch_size: 10\n            actions: ['create']", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#manage_entitites-explanation", 
            "text": "You can add as many entities as you like. Each of them must have the following attributes :   entity_name : full name of the entity  form_name : full name of the form corresponding to this entity. This form will be used to bind the given parameters to the new entity (see section TODO for more details)  actions : array of action. At the moment, we only support create and delete  batch_size : number of message to take from the queue at a time.", 
            "title": "manage_entitites explanation"
        }, 
        {
            "location": "/api/", 
            "text": "REST Controller\n\n\nPrincipe\n\n\nThis bundle provide a create method.\nWhen using our REST Controller, you have to call the POST /batches with a json like this\n\n\n{\n    \noperations\n:[{\n        \ntype\n:\nneed\n,\n        \naction\n:\ncreate\n,\n        \nplace\n:{\nsearchedBy\n:\nroute\n,\nroute\n:\nRue de Dunkerque\n,\nlocality\n:\nParis\n,\nadministrativeArealevel1\n:\n\u00cele-de-France\n,\ncountry\n:\nFrance\n,\nname\n:\nRue de Dunkerque, Paris, France\n,\nlatitude\n:48.8807242, \nlongitude\n:2.351648399999931},\n        \ndescription\n:\nle test du batch du need2\n,\n        \ntitldzdezdezdezddee\n:\nle test du batch du need2\n,\n        \ncategory\n:11,\n        \nauthor\n:2\n    },{\n        \ntype\n:\nneed\n,\n        \naction\n:\ncreate\n,\n        \nplace\n:{\nsearchedBy\n:\nroute\n,\nroute\n:\nRue de Dunkerque\n,\nlocality\n:\nParis\n,\nadministrativeArealevel1\n:\n\u00cele-de-France\n,\ncountry\n:\nFrance\n,\nname\n:\nRue de Dunkerque, Paris, France\n,\nlatitude\n:48.8807242, \nlongitude\n:2.351648399999931},\n        \ndescription\n:\nle test du batch du need2\n,\n        \ntitldzdezdezdezddee\n:\nle test du batch du need2\n,\n        \ncategory\n:11,\n        \nauthor\n:2\n    }]\n}\n\n\n\nRequired parameters\n\n\nFor each operation, you have to give the following required parameters are\n* Type =\n it must be a manage_entity\n* Action =\n create/delete. it must be in the action array in your manage_entity\n* Remainning parameters =\n contains all the data you need to create/delete an entity\n\n\nAvailable routes\n\n\n\n\nBatch : GET /batches/{id}, POST /batches, DELETE /batches/{id}\n\n\nOperation : GET /operations/{id}\n\n\n\n\nFor more detailled options for these routes, you can use nelmioApiDocBundle. our routes are commented, and you will find the documentation.", 
            "title": "API"
        }, 
        {
            "location": "/api/#rest-controller", 
            "text": "", 
            "title": "REST Controller"
        }, 
        {
            "location": "/api/#principe", 
            "text": "This bundle provide a create method.\nWhen using our REST Controller, you have to call the POST /batches with a json like this  {\n     operations :[{\n         type : need ,\n         action : create ,\n         place :{ searchedBy : route , route : Rue de Dunkerque , locality : Paris , administrativeArealevel1 : \u00cele-de-France , country : France , name : Rue de Dunkerque, Paris, France , latitude :48.8807242,  longitude :2.351648399999931},\n         description : le test du batch du need2 ,\n         titldzdezdezdezddee : le test du batch du need2 ,\n         category :11,\n         author :2\n    },{\n         type : need ,\n         action : create ,\n         place :{ searchedBy : route , route : Rue de Dunkerque , locality : Paris , administrativeArealevel1 : \u00cele-de-France , country : France , name : Rue de Dunkerque, Paris, France , latitude :48.8807242,  longitude :2.351648399999931},\n         description : le test du batch du need2 ,\n         titldzdezdezdezddee : le test du batch du need2 ,\n         category :11,\n         author :2\n    }]\n}", 
            "title": "Principe"
        }, 
        {
            "location": "/api/#required-parameters", 
            "text": "For each operation, you have to give the following required parameters are\n* Type =  it must be a manage_entity\n* Action =  create/delete. it must be in the action array in your manage_entity\n* Remainning parameters =  contains all the data you need to create/delete an entity", 
            "title": "Required parameters"
        }, 
        {
            "location": "/api/#available-routes", 
            "text": "Batch : GET /batches/{id}, POST /batches, DELETE /batches/{id}  Operation : GET /operations/{id}   For more detailled options for these routes, you can use nelmioApiDocBundle. our routes are commented, and you will find the documentation.", 
            "title": "Available routes"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nThe purpose is to manage a very long list of create/delete for you entity. for this we use these steps\n\n\n\n\nConfigure consumers/producers queue\n\n\nCall the batch_service with an array of operation\n\n\nCreate and save the batch\n\n\nfor each operations, create and save + send a message to the queue with the producer\n\n\nThe consumer take the message, and execute the given operation.\n\n\n\n\nConfigure consumers/producers queue\n\n\nWe automatically create a couple of producers/consumers for each actions of a manage_entity. if you take this example\n\n\n    manage_entities: #Batchable entity\n        need:\n            entity_name: AppBundle\\Entity\\Need\n            form_name: ApiBundle\\Form\\NeedType\n            batch_size: 10\n            actions: ['create','delete']\n        proposition:\n            entity_name: AppBundle\\Entity\\Proposition\n            form_name: ApiBundle\\Form\\PropositionType\n            batch_size: 10\n            actions: ['create']\n\n\n\nit will automatically create queues named\n* welp.batch.need.create\n* welp.batch.need.delete\n* welp.batch.proposition.create\n\n\nCall the batch_service\n\n\nThe service is called \nwelp_batch.batch_service\n. It is the main entrance to this bundle. You can use it in your controller, or you can use our REST controller.\n\n\nThis service provide a create method. This method accept an array parameter, which contain all the operations you want to batch.\nWhen using our REST Controller, you have to call the POST /batches with a json like this\n\n\n{\n    \noperations\n:[{\n        \ntype\n:\nneed\n,\n        \naction\n:\ncreate\n,\n        \nplace\n:{\nsearchedBy\n:\nroute\n,\nroute\n:\nRue de Dunkerque\n,\nlocality\n:\nParis\n,\nadministrativeArealevel1\n:\n\u00cele-de-France\n,\ncountry\n:\nFrance\n,\nname\n:\nRue de Dunkerque, Paris, France\n,\nlatitude\n:48.8807242, \nlongitude\n:2.351648399999931},\n        \ndescription\n:\nle test du batch du need2\n,\n        \ntitldzdezdezdezddee\n:\nle test du batch du need2\n,\n        \ncategory\n:11,\n        \nauthor\n:2\n    },{\n        \ntype\n:\nneed\n,\n        \naction\n:\ncreate\n,\n        \nplace\n:{\nsearchedBy\n:\nroute\n,\nroute\n:\nRue de Dunkerque\n,\nlocality\n:\nParis\n,\nadministrativeArealevel1\n:\n\u00cele-de-France\n,\ncountry\n:\nFrance\n,\nname\n:\nRue de Dunkerque, Paris, France\n,\nlatitude\n:48.8807242, \nlongitude\n:2.351648399999931},\n        \ndescription\n:\nle test du batch du need2\n,\n        \ntitldzdezdezdezddee\n:\nle test du batch du need2\n,\n        \ncategory\n:11,\n        \nauthor\n:2\n    }]\n}\n\n\n\nCreate and save the batch\n\n\nWith this example, it will add 2 operations to the queue welp.batch.need.create\nWhen the service receive the request, it will create a batch. Then, for each operations (two in the given example), it will create and save operations.\nThose operations are transmit to the \nwelp_batch.producer\n thanks to the \nproduce\n method\n\n\nPublish to the broker\n\n\nWhen the \nproduce($operation, $batchId,$type,$action )\n method is called. The parameters will be add to an array formated like this :\n\n\n    $message = array();\n    $message['batchId']=$batchId;\n    $message['operationId']=$operation-\ngetId();\n    $message['type']=$type;\n    $message['action']=$action;\n\n\n\nThis message will then be publish to rabbitMQ, using the right queue, determine with the type and the action\n\n\nExecute actions\n\n\nWe automatically create consumers connected to all our queues.\nYou have to add the consumers to your supervisord.\n\n\nConsumers will get a message, and laucnh the \nexecute(AMQPMessage $msg)\n.\n\n\nThe message will be unserialized, and the operation will be executed. Following the given action, the create or the delete method will be used.\n\n\nUpdate batch/operation status\n\n\nDuring the process of the excution of the producers, we dispatch some events\n* WELP_BATCH_OPERATION_STARTED\n* WELP_BATCH_OPERATION_FINISHED\n* WELP_BATCH_OPERATION_ERROR\n\n\nEvents are listened in the \nOperationListener.php\n.\n\n\nWhen the \nWELP_BATCH_OPERATION_STARTED\n event is raised, we update the status of the operation, and if necessary, the status of the batch.\n\n\nWhen the \nWELP_BATCH_OPERATION_ERROR\n event is raised, we update the status of the operation, and we add the code and the message of the error in the error array.\n\n\nWhen the \nWELP_BATCH_OPERATION_FINISHED\n event is raised, we update the status of the operation. If all operations are finished, we update the status of the batch, and we merge all errors in the batch error array.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "The purpose is to manage a very long list of create/delete for you entity. for this we use these steps   Configure consumers/producers queue  Call the batch_service with an array of operation  Create and save the batch  for each operations, create and save + send a message to the queue with the producer  The consumer take the message, and execute the given operation.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#configure-consumersproducers-queue", 
            "text": "We automatically create a couple of producers/consumers for each actions of a manage_entity. if you take this example      manage_entities: #Batchable entity\n        need:\n            entity_name: AppBundle\\Entity\\Need\n            form_name: ApiBundle\\Form\\NeedType\n            batch_size: 10\n            actions: ['create','delete']\n        proposition:\n            entity_name: AppBundle\\Entity\\Proposition\n            form_name: ApiBundle\\Form\\PropositionType\n            batch_size: 10\n            actions: ['create']  it will automatically create queues named\n* welp.batch.need.create\n* welp.batch.need.delete\n* welp.batch.proposition.create", 
            "title": "Configure consumers/producers queue"
        }, 
        {
            "location": "/usage/#call-the-batch_service", 
            "text": "The service is called  welp_batch.batch_service . It is the main entrance to this bundle. You can use it in your controller, or you can use our REST controller.  This service provide a create method. This method accept an array parameter, which contain all the operations you want to batch.\nWhen using our REST Controller, you have to call the POST /batches with a json like this  {\n     operations :[{\n         type : need ,\n         action : create ,\n         place :{ searchedBy : route , route : Rue de Dunkerque , locality : Paris , administrativeArealevel1 : \u00cele-de-France , country : France , name : Rue de Dunkerque, Paris, France , latitude :48.8807242,  longitude :2.351648399999931},\n         description : le test du batch du need2 ,\n         titldzdezdezdezddee : le test du batch du need2 ,\n         category :11,\n         author :2\n    },{\n         type : need ,\n         action : create ,\n         place :{ searchedBy : route , route : Rue de Dunkerque , locality : Paris , administrativeArealevel1 : \u00cele-de-France , country : France , name : Rue de Dunkerque, Paris, France , latitude :48.8807242,  longitude :2.351648399999931},\n         description : le test du batch du need2 ,\n         titldzdezdezdezddee : le test du batch du need2 ,\n         category :11,\n         author :2\n    }]\n}", 
            "title": "Call the batch_service"
        }, 
        {
            "location": "/usage/#create-and-save-the-batch", 
            "text": "With this example, it will add 2 operations to the queue welp.batch.need.create\nWhen the service receive the request, it will create a batch. Then, for each operations (two in the given example), it will create and save operations.\nThose operations are transmit to the  welp_batch.producer  thanks to the  produce  method", 
            "title": "Create and save the batch"
        }, 
        {
            "location": "/usage/#publish-to-the-broker", 
            "text": "When the  produce($operation, $batchId,$type,$action )  method is called. The parameters will be add to an array formated like this :      $message = array();\n    $message['batchId']=$batchId;\n    $message['operationId']=$operation- getId();\n    $message['type']=$type;\n    $message['action']=$action;  This message will then be publish to rabbitMQ, using the right queue, determine with the type and the action", 
            "title": "Publish to the broker"
        }, 
        {
            "location": "/usage/#execute-actions", 
            "text": "We automatically create consumers connected to all our queues.\nYou have to add the consumers to your supervisord.  Consumers will get a message, and laucnh the  execute(AMQPMessage $msg) .  The message will be unserialized, and the operation will be executed. Following the given action, the create or the delete method will be used.", 
            "title": "Execute actions"
        }, 
        {
            "location": "/usage/#update-batchoperation-status", 
            "text": "During the process of the excution of the producers, we dispatch some events\n* WELP_BATCH_OPERATION_STARTED\n* WELP_BATCH_OPERATION_FINISHED\n* WELP_BATCH_OPERATION_ERROR  Events are listened in the  OperationListener.php .  When the  WELP_BATCH_OPERATION_STARTED  event is raised, we update the status of the operation, and if necessary, the status of the batch.  When the  WELP_BATCH_OPERATION_ERROR  event is raised, we update the status of the operation, and we add the code and the message of the error in the error array.  When the  WELP_BATCH_OPERATION_FINISHED  event is raised, we update the status of the operation. If all operations are finished, we update the status of the batch, and we merge all errors in the batch error array.", 
            "title": "Update batch/operation status"
        }
    ]
}